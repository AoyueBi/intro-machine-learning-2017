# Support vector machines {#svm}

## Introduction
Support vector machines (SVMs) are models of supervised learning. The SVM approach emerged from the computer science community in the 1990s. This chapter will focus exclusively on the use of SVMs for classification, but it should be noted that they can also be used for regression. The SVM is an extension of the support vector classifier (SVC), which is turn is an extension of the maximum margin classifier.

### Maximum margin classifier
Let's start by definining a hyperplane. In _p_-dimensional space a hyperplane is a flat affine subspace of _p_-1. 

```{r svmSeparatingHyperplanes, echo=FALSE, out.width='75%', fig.align='center', fig.cap="Separating hyperplanes. H1 does not separate the classes. H2 does, but only with a small margin. H3 separates them with the maximum margin. By User:ZackWeinberg, based on PNG version by User:Cyc [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons"}
knitr::include_graphics("images/Svm_separating_hyperplanes.svg")
```

```{r svmKernelMachine, echo=FALSE, out.width='75%', fig.align='center', fig.cap="Kernel machine. By Alisneaky - Own work, CC0, https://commons.wikimedia.org/w/index.php?curid=14941564"}
knitr::include_graphics("images/svm_kernel_machine.png")
```

```{r svmMaxSepHyperplaneWithMargin, echo=F, out.width='75%', fig.align='center', fig.cap="Maximum-margin hyperplane and margins for an SVM trained with samples from two classes. Samples on the margin are called the support vectors. By Cyc - Own work, Public Domain, https://commons.wikimedia.org/w/index.php?curid=3566688"}
knitr::include_graphics("images/Svm_max_sep_hyperplane_with_margin.png")
```


<!-- Matt -->

<!--REPEAT CLASSIFICATION EXAMPLE FOR SERUM PROTEOMICS -->

<!-- regression and classification -->


```{r echo=T}


```


## Example - training an SVM




### Example - simulated data

```{r echo=T}
linearly_separable <- read.csv("data/sim_data_svm/linearly_separable.csv", header=F)
circles <- read.csv("data/sim_data_svm/circles.csv", header=F)
moons <- read.csv("data/sim_data_svm/moons.csv", header=F)
```

### Example -  cell segmentation data
Load required libraries
```{r echo=T}
library(caret)

```


Setup parallel processing
```{r echo=T}
library(doMC)
registerDoMC()
getDoParWorkers()
```

MUST GENERATE A LIST OF SEEDS IF WE USE PARALLEL PROCESSING, FOR REPRODUCIBILITY

## Exercises

### Exercise 1

In this exercise we will return to the cell segmentation data set that we attempted to classify in section \@knn-cell-segmentation of the nearest neighbours chapter.
```{r echo=T}
data(segmentationData)
```

The aim of the exercise is to build a binary classifier to predict the quality of segmentation (poorly segmented or well segmented) based on the various morphological features. Do not worry about feature selection, but you may want to pre-process the data. Select a radial kernel SVM and tune over the cost function C. Produce a ROC curve to show the performance of the classifier on the test set. 


Solutions to exercises can be found in appendix \@ref(solutions-svm)

<!--

## Serum proteomics
```{r echo=T}
centre1 <- read.csv("data/serum_proteomics/male_centre1.csv")
centre2 <- read.csv("data/serum_proteomics/male_centre2.csv")

diag_cent1 <- centre1$Diagnostic_group
prot_cent1 <- centre1[,2:18]

diag_cent2 <- centre2$Diagnostic_group
prot_cent2 <- centre2[,2:18]

# featurePlot(x=prot_cent1, y=diag_cent1, plot="pairs")

transformations <- preProcess(prot_cent1, 
                              method=c("center", "scale"),
                              cutoff=0.75)
prot_cent1 <- predict(transformations, prot_cent1)

svmTune <- train(x = prot_cent1,
                 y = diag_cent1,
                 method = "svmRadial",
                 # The default grid of cost parameters go from 2^-2,
                 # 0.5 to 1,
                 # Well fit 9 values in that sequence via the tuneLength
                 # argument.
                 tuneLength = 9,
                 ## Also add options from preProcess here too
                 preProc = c("center", "scale"),
                 metric = "ROC",
                 trControl = cvCtrl)

svmTune

svmTune$finalModel

```

-->
