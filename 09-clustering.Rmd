# Clustering {#clustering}

<!-- Matt -->

<!-- http://www.madgroup.path.cam.ac.uk/microarraysummary.shtml -->

## Introduction

Hierarchic (produce dendrogram) vs partitioning methods


```{r clusterTypes, fig.cap='Example clusters. **A**, *blobs*; **B**, *aggregation* [@Gionis2007]; **C**, *noisy moons*; **D**, *noisy circles*; **E**, *D31* [@Veenman2002]; **F**, *no structure*.', out.width='80%', fig.asp=1.2, fig.align='center', echo=F}
library(ggplot2)
library(GGally)

blobs <- read.csv("data/example_clusters/blobs.csv", header=F)
aggregation <- read.table("data/example_clusters/aggregation.txt")
noisy_moons <- read.csv("data/example_clusters/noisy_moons.csv", header=F)
noisy_circles <- read.csv("data/example_clusters/noisy_circles.csv", header=F)
d31 <- read.table("data/example_clusters/D31.txt")
noStructure <- read.csv("data/example_clusters/no_structure.csv", header=F)

plotList <- list(
qplot(x=V1, y=V2, data=blobs, geom="point", size=I(0.2)) + annotate("text",
                                                                    x=(0.01 * (max(blobs$V1)-min(blobs$V1))) + min(blobs$V1), 
                                                                    y=(0.9 * (max(blobs$V2)-min(blobs$V2))) + min(blobs$V2), 
                                                                    label ="A", size=8, col="blue"),
qplot(x=V1, y=V2, data=aggregation, geom="point", size=I(0.2)) + annotate("text",
                                                                          x=(0.01 * (max(aggregation$V1)-min(aggregation$V1))) + min(aggregation$V1), 
                                                                          y=(0.9 * (max(aggregation$V2)-min(aggregation$V2))) + min(aggregation$V2), 
                                                                          label="B", size=8, col="blue"),
qplot(x=V1, y=V2, data=noisy_moons, geom="point", size=I(0.2)) + annotate("text",
                                                                         x=(0.01 * (max(noisy_moons$V1)-min(noisy_moons$V1))) + min(noisy_moons$V1),
                                                                         y=(0.9 * (max(noisy_moons$V2)-min(noisy_moons$V2))) + min(noisy_moons$V2),
                                                                         label="C", size=8, col="blue"),
qplot(x=V1, y=V2, data=noisy_circles, geom="point", size=I(0.2)) + annotate("text",
                                                                           x=(0.01 * (max(noisy_circles$V1)-min(noisy_circles$V1))) + min(noisy_circles$V1),
                                                                           y=(0.9 * (max(noisy_circles$V2)-min(noisy_circles$V2))) + min(noisy_circles$V2),
                                                                           label="D", size=8, col="blue"),
qplot(x=V1, y=V2, data=d31, geom="point", size=I(0.2)) + annotate("text",
                                                                  x=(0.01 * (max(d31$V1)-min(d31$V1))) + min(d31$V1),
                                                                  y=(0.9 * (max(d31$V2)-min(d31$V2))) + min(d31$V2),
                                                                  label="E", size=8, col="blue"),
qplot(x=V1, y=V2, data=noStructure, geom="point", size=I(0.2)) + annotate("text",
                                                                         x=(0.01 * (max(noStructure$V1)-min(noStructure$V1))) + min(noStructure$V1),
                                                                         y=(0.9 * (max(noStructure$V2)-min(noStructure$V2))) + min(noStructure$V2),
                                                                         label="F", size=8, col="blue")
)

pm <- ggmatrix(
  plotList, nrow=3, ncol=2, showXAxisPlotLabels = F, showYAxisPlotLabels = F
) + theme_bw()

pm
```

## Distance metrics


**Minkowski distance:**
\begin{equation}
  distance\left(x,y,p\right)=\left(\sum_{i=1}^{n} abs(x_i-y_i)^p\right)^{1/p}
  (\#eq:minkowski)
\end{equation}

Graphical explanation of euclidean, manhattan and max (Chebyshev?)


### Image segmentation



## Hierarchic methods

```{r echo=F}
m <- matrix(c(rep(NA,5),
       2,rep(NA,4),
       6,5,rep(NA,3),
       10,10,5,rep(NA,2),
       9,8,3,4,NA),ncol=5,byrow=T,
       dimnames=list(LETTERS[1:5], LETTERS[1:5])
)

mDisplay <- matrix(c(
       2,rep("",3),
       6,5,rep("",2),
       10,10,5,rep("",1),
       9,8,3,4),ncol=4,byrow=T,
       dimnames=list(LETTERS[2:5], LETTERS[1:4])
)

d <- as.dist(m)
```

```{r distance-matrix, tidy=FALSE, echo=F}
knitr::kable(
  mDisplay, caption = 'Example distance matrix',
  booktabs = TRUE
)
```

### Linkage algorithms
Make one section
panel of three dendrograms
one table

Single linkage - nearest neighbours linkage
Complete linkage - furthest neighbours linkage
Average linkage - UPGMA (Unweighted Pair Group Method with Arithmetic Mean) 

```{r echo=F}
hclustSingle <- hclust(d, method="single")
hclustComplete <- hclust(d, method="complete")
hclustAverage <- hclust(d, method="average")
```



```{r distance-merge, tidy=FALSE, echo=F}
Single <- c(0,hclustSingle$height)
Complete <- c(0,hclustComplete$height)
Average <- c(0,hclustAverage$height)
Groups <- c("A,B,C,D,E", "(A,B),C,D,E", "(A,B),(C,E),D", "(A,B)(C,D,E)", "(A,B,C,D,E)")
distanceMerge <- as.data.frame(cbind(Groups,Single,Complete,Average))
knitr::kable(
  distanceMerge, caption = 'Merge distances for objects in the example distance matrix using three different linkage methods.',
  booktabs = TRUE
) 

```

```{r linkageComparison, fig.cap='Dendrograms for the example distance matrix using three different linkage methods. ', out.width='100%', fig.asp=0.3, fig.align='center', fig.show='hold',echo=F}
library(ggdendro)

dend_single <- as.dendrogram(hclustSingle)
dend_complete <- as.dendrogram(hclustComplete)
dend_average <- as.dendrogram(hclustAverage)

dd_single <- dendro_data(dend_single, type="rectangle")
dd_complete <- dendro_data(dend_complete, type="rectangle")
dd_average <- dendro_data(dend_average, type="rectangle")

p_single <- ggplot(segment(dd_single)) +
  geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +
  coord_flip() +
  scale_y_reverse(expand=c(0.05,0)) +
  ggtitle("Single linkage") +
  geom_text(aes(x = x, y = y, label = label, angle = 0, hjust = -1), data= label(dd_single)) +
  ylab("Distance") +
  theme(axis.title.y=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank())
p_single

p_complete <- ggplot(segment(dd_complete)) +
  geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +
  coord_flip() +
  scale_y_reverse(expand=c(0.05,0)) +
  ggtitle("Complete linkage") +
  geom_text(aes(x = x, y = y, label = label, angle = 0, hjust = -1), data= label(dd_complete)) +
  ylab("Distance") +
  theme(axis.title.y=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank())
p_complete

p_average <- ggplot(segment(dd_average)) +
  geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +
  coord_flip() +
  scale_y_reverse(expand=c(0.05,0)) +
  ggtitle("Average linkage") +
  geom_text(aes(x = x, y = y, label = label, angle = 0, hjust = -1), data= label(dd_average)) +
  ylab("Distance") +
  theme(axis.title.y=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank())
p_average

```

### Example: clustering toy data sets

```{r, echo=T}
library(RColorBrewer)
library(dendextend)
library(ggplot2)
library(GGally)

cluster_colours <- brewer.pal(8,"Dark2")

blobs <- read.csv("data/example_clusters/blobs.csv", header=F)

```

```{r hclustToyData, fig.cap='Hierarchical clustering of toy data-sets. ', out.width='75%', fig.asp=1.5, fig.align='center',echo=T}

aggregation <- read.table("data/example_clusters/aggregation.txt")
noisy_moons <- read.csv("data/example_clusters/noisy_moons.csv", header=F)
noisy_circles <- read.csv("data/example_clusters/noisy_circles.csv", header=F)
no_structure <- read.csv("data/example_clusters/no_structure.csv", header=F)

hclust_plots <- function(data_set, n){
  d <- dist(data_set[,1:2])
  dend <- as.dendrogram(hclust(d, method="average"))
  clusters <- cutree(dend,n,order_clusters_as_data=F)
  dend <- color_branches(dend, clusters=clusters, col=cluster_colours[1:n])
  clusters <- clusters[order(as.numeric(names(clusters)))]
  labels(dend) <- rep("", length(data_set[,1]))
  ggd <- as.ggdend(dend)
  ggd$nodes <- ggd$nodes[!(1:length(ggd$nodes[,1])),]
  plotPair <- list(ggplot(ggd),
    ggplot(data_set, aes(V1,V2)) + geom_point(col=cluster_colours[clusters], size=0.2))
  return(plotPair)
}

plotList <- c(
  hclust_plots(aggregation, 7),
  hclust_plots(noisy_moons, 2),
  hclust_plots(noisy_circles, 2),
  hclust_plots(no_structure, 3)
)

pm <- ggmatrix(
  plotList, nrow=4, ncol=2, showXAxisPlotLabels = F, showYAxisPlotLabels = F, xAxisLabels=c("dendrogram", "scatter plot"), yAxisLabels=c("aggregation", "noisy moons", "noisy circles", "no structure")
) + theme_bw()

pm

```

### Example: gene expression profiling of human tissues
Load required libraries
```{r echo=T}
library(RColorBrewer)
library(dendextend)
```

Load data
```{r echo=T}
load("data/tissues_gene_expression/tissuesGeneExpression.rda")
```

Inspect data
```{r echo=T}
table(tissue)
dim(e)
```

Compute distance between each sample
```{r echo=T} 
d <- dist(t(e))
```

perform hierarchical clustering
```{r tissueDendrogram, fig.cap='Clustering of tissue samples based on gene expression profiles. ', out.width='100%', fig.asp=0.7, fig.align='center', echo=T}
hc <- hclust(d, method="average")
plot(hc, labels=tissue, cex=0.5, hang=-1, xlab="", sub="")
```

use dendextend library to plot dendrogram with colour labels
```{r tissueDendrogramColour, fig.cap='Clustering of tissue samples based on gene expression profiles with labels coloured by tissue type. ', out.width='100%', fig.asp=3, fig.align='center', echo=T}
tissue_type <- unique(tissue)
dend <- as.dendrogram(hc)
dend_colours <- brewer.pal(length(unique(tissue)),"Dark2")
names(dend_colours) <- tissue_type
labels(dend) <- tissue[order.dendrogram(dend)]
labels_colors(dend) <- dend_colours[tissue][order.dendrogram(dend)]
labels_cex(dend) = 0.5
plot(dend, horiz=T)
```

Define clusters by cutting tree at a specific height
```{r tissueDendrogramCutHeight, fig.cap='Clusters found by cutting tree at a height of 125', out.width='100%', fig.asp=3, fig.align='center', echo=T}
plot(dend, horiz=T)
abline(v=125, lwd=2, lty=2, col="blue")
hclusters <- cutree(dend, h=125)
table(tissue, cluster=hclusters)
```

Select a specific number of clusters.
```{r tissueDendrogramEightClusters, fig.cap='Selection of eight clusters from the dendogram', out.width='100%', fig.asp=3, fig.align='center', echo=T}
plot(dend, horiz=T)
abline(v = heights_per_k.dendrogram(dend)["8"], lwd = 2, lty = 2, col = "blue")
hclusters <- cutree(dend, k=8)
table(tissue, cluster=hclusters)
```

## Partitioning methods

### K-means

Pseudocode

to illustrate range of different types of data that can be clustered - image segmentation

```{r kmeansIterations, fig.cap='Iterations of the k-means algorithm', out.width='90%', fig.asp=1.2, fig.align='center',echo=F}
library(RColorBrewer)
point_shapes <- c(17,19)
point_colours <- brewer.pal(3,"Dark2")
point_size = 4
center_point_size = 8
load("data/example_clusters/kmeans_iteration_demo.rda")
# current_centers=initial_centroids

plotList <- list(
 ggplot(kmeans_demo_df, aes(V1,V2)) + geom_point(col="grey30", shape=15, size=point_size) + geom_point(data=initial_centroids, aes(V1,V2), shape=3, col="black", size=center_point_size) +theme_bw())

plot_kmeans_result <- function(iterations,dat,centers) {
  res <- suppressWarnings(kmeans(dat,centers=centers, iter.max=iterations, algorithm="Lloyd"))
  current_centers <- as.data.frame(res$centers)
  ggplot(kmeans_demo_df, aes(V1,V2)) + geom_point(col=point_colours[res$cluster], shape=point_shapes[res$cluster], size=point_size) + geom_point(data=current_centers, aes(V1,V2), shape=3, col="black", size=center_point_size) + theme_bw() + 
    annotate("text", x=-7, y=7, label =paste("Iter.", iterations, sep=" "), size=8, col="black")
}

plotList <- c(plotList, lapply(c(1,3,2,4), plot_kmeans_result, dat=kmeans_demo_df, centers=initial_centroids))

pm <- ggmatrix(
  plotList, nrow=3, ncol=2, showXAxisPlotLabels = F, showYAxisPlotLabels = F
) + theme_bw()

pm

```




### DBSCAN
Density-based spatial clustering of applications with noise

### Gene expression
tissue types?


## Summary

### Applications

### Strengths

### Limitations

<!--
Not appropriate for phylogenetic analysis!!
-->

## Exercises

<!--
1. Toy clusters
2. mouse mammary time-course (kmeans and dbscan)
3. dimensionality reduction before clustering (helpful for visualization if using a partitioning method) - possibly use parasite data?
4. exercise involving heatmap

-->


Exercise solutions: \@ref(solutions-clustering)

Solutions to exercises can be found in appendix \@ref(solutions-clustering).


